<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;RestTemplate Module</title><link rel="stylesheet" href="css/manual.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring for Android Reference Manual"><link rel="up" href="index.html" title="Spring for Android Reference Manual"><link rel="prev" href="overview.html" title="1.&nbsp;Spring for Android Overview"><link rel="next" href="auth.html" title="3.&nbsp;Auth Module"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;RestTemplate Module</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="overview.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="auth.html">Next</a></td></tr></table><hr></div><div class="chapter" title="2.&nbsp;RestTemplate Module"><div class="titlepage"><div><div><h2 class="title"><a name="rest-template"></a>2.&nbsp;RestTemplate Module</h2></div></div></div>
 

  <div class="section" title="2.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-introduction"></a>2.1&nbsp;Introduction</h2></div></div></div>
	
	
	
	<p>Spring's RestTemplate is a robust, popular Java-based REST client. The Spring for Android RestTemplate Module provides a version of RestTemplate that works in an Android environment.</p>
	
  </div>

  <div class="section" title="2.2&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-overview"></a>2.2&nbsp;Overview</h2></div></div></div>
	
		
	
	<p>The <code class="classname">RestTemplate</code> class is the heart of the Spring for Android RestTemplate library. It is conceptually similar to other template classes found in other Spring portfolio projects. RestTemplate's behavior is customized by providing callback methods and configuring the <code class="interfacename">HttpMessageConverter</code> used to marshal objects into the HTTP request body and to unmarshal any response back into an object. When you create a new <code class="classname">RestTemplate</code> instance, the constructor sets up several supporting objects that make up the RestTemplate functionality.</p>
			
	<p>Here is an overview of the functionality supported within <code class="classname">RestTemplate</code>.</p>
	
	<div class="section" title="2.2.1&nbsp;HTTP Client"><div class="titlepage"><div><div><h3 class="title"><a name="d4e37"></a>2.2.1&nbsp;HTTP Client</h3></div></div></div>
		
		
		
		<p><code class="classname">RestTemplate</code> provides an abstraction for making RESTful HTTP requests, and internally, <code class="classname">RestTemplate</code> utilizes a native Android HTTP client library for those requests. There are two native HTTP clients available on Android, the standard J2SE facilities, and the <a class="ulink" href="http://hc.apache.org/httpcomponents-client-ga/index.html" target="_top">HttpComponents HttpClient</a>. The standard JS2SE facilities are made available through the <code class="classname">SimpleClientHttpRequestFactory</code>, while the HttpClient is made available through the <code class="classname">HttpComponentsClientHttpRequestFactory</code>. The default <code class="interfacename">ClientHttpRequestFactory</code> used when you create a new <code class="classname">RestTemplate</code> instance differs based on the version of Android on which your application is running.</p>

		<p>Google recommends to use the J2SE facilities on <a class="ulink" href="http://android-developers.blogspot.com/2011/09/androids-http-clients.html" target="_top">Gingerbread (Version 2.3)</a> and newer, while previous versions should use the HttpComponents HttpClient. Based on this recommendation <code class="classname">RestTemplate</code> checks the version of Android on which your app is running and uses the appropriate <code class="interfacename">ClientHttpRequestFactory</code>. To utilize a specific <code class="interfacename">ClientHttpRequestFactory</code> you must either pass a new instance into the <code class="classname">RestTemplate</code> constructor, or call <code class="methodname">setRequestFactory(ClientHttpRequestFactory requestFactory)</code> on an existing <code class="classname">RestTemplate</code> instance.</p>
		
	</div>
	
	<div class="section" title="2.2.2&nbsp;Gzip Compression"><div class="titlepage"><div><div><h3 class="title"><a name="d4e55"></a>2.2.2&nbsp;Gzip Compression</h3></div></div></div>
		
		
		
		<p><code class="classname">RestTemplate</code> supports sending and receiving data encoded with gzip compression. The HTTP specification allows for additional values in the <code class="literal">Accept-Encoding</code> header field, however <code class="classname">RestTemplate</code> only supports gzip compression at this time.</p>
		
	</div>
	
	<div class="section" title="2.2.3&nbsp;Object to JSON Marshaling"><div class="titlepage"><div><div><h3 class="title"><a name="d4e61"></a>2.2.3&nbsp;Object to JSON Marshaling</h3></div></div></div>
		
		
		
		<p>Object to JSON marshaling in Spring for Android RestTemplate requires the use of a third party JSON mapping library. There are two libraries supported in Spring for Android, <a class="ulink" href="http://jackson.codehaus.org" target="_top">Jackson JSON Processor</a>, and <a class="ulink" href="http://code.google.com/p/google-gson/" target="_top">Google Gson</a>. While Jackson is a well known JSON parsing library, the Gson library is smaller, which would result in an smaller Android app when packaged.</p>
		
	</div>
	
	<div class="section" title="2.2.4&nbsp;Object to XML Marshaling"><div class="titlepage"><div><div><h3 class="title"><a name="d4e66"></a>2.2.4&nbsp;Object to XML Marshaling</h3></div></div></div>
		
		
		
		<p>Object to XML marshaling in Spring for Android RestTemplate requires the use of a third party XML mapping library. The <a class="ulink" href="http://simple.sourceforge.net" target="_top">Simple XML serializer</a> is used to provide this marshaling functionality.</p>
		
	</div>
	
	<div class="section" title="2.2.5&nbsp;RSS and Atom Support"><div class="titlepage"><div><div><h3 class="title"><a name="d4e70"></a>2.2.5&nbsp;RSS and Atom Support</h3></div></div></div>
		
		
		
		<p>RSS and Atom feed support in Spring for Android RestTemplate requires the use of a third party feed reader library. The <a class="ulink" href="http://code.google.com/p/android-rome-feed-reader" target="_top">Android ROME Feed Reader</a> is used to provide this functionality.</p>
		
	</div>
	
  </div>

  <div class="section" title="2.3&nbsp;How to get"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-howtoget"></a>2.3&nbsp;How to get</h2></div></div></div>

	

	<p>There are a few methods for including external jars in your Android app. One is to manually download them and include them in your app's <code class="literal">libs/</code> folder. Another option is to use Maven for dependency management.</p>

	<div class="section" title="2.3.1&nbsp;Standard Installation"><div class="titlepage"><div><div><h3 class="title"><a name="d4e78"></a>2.3.1&nbsp;Standard Installation</h3></div></div></div>

		

		<p>In order to use RestTemplate in your Android application, you must include the following Spring for Android jars in the <code class="literal">libs/</code> folder. These are available from the SpringSource <a class="ulink" href="http://www.springsource.org/download/community?project=Spring%20for%20Android" target="_top">Community Downloads</a> page.

			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="literal">spring-android-rest-template-{version}.jar</code></li><li class="listitem"><code class="literal">spring-android-core-{version}.jar</code></li></ul></div><p>

		</p>

		<p>If you are building your project with Ant, Ant will automatically include any jars located in the <code class="literal">libs/</code> folder located in the root of your project. However, in Eclipse you must manually add the jars to the Build Path. Follow these steps to add the jars to your existing Android project in Eclipse.

		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Refresh the project in Eclipse so the <code class="literal">libs/</code> folder and jars display in the Package Explorer.</li><li class="listitem">Right-Click (Command-Click) the first jar.</li><li class="listitem">Select the <code class="literal">BuildPath</code> submenu.</li><li class="listitem">Select <code class="literal">Add to Build Path</code> from the context menu.</li><li class="listitem">Repeat these steps for each jar.</li></ol></div><p>

		</p>

	</div>

	<div class="section" title="2.3.2&nbsp;Maven Dependencies"><div class="titlepage"><div><div><h3 class="title"><a name="d4e99"></a>2.3.2&nbsp;Maven Dependencies</h3></div></div></div>

		

		<p>Google's provided Android toolset does not include dependency management support. However, through the use of third party tools, you can use Maven to manage dependencies and build your Android app. See the <a class="link" href="spring-android-maven.html" title="5.&nbsp;Maven Dependency Management">Spring for Android and Maven</a> section for more information. Additional dependencies may be required, depending on which HTTP Message Converters you are using within RestTemplate. See the <a class="link" href="rest-template.html#rest-template-message-converters" title="2.6&nbsp;HTTP Message Conversion">Message Converters</a> section for more information.</p>

		<p>Add the spring-android-rest-template artifact to your classpath:

			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.android<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>spring-android-rest-template<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${spring-android-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>

		</p>
		
		<p>The transitive dependencies are automatically imported by Maven, but they are listed here for clarity.

			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.android<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>spring-android-core<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${spring-android-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>
		
		</p>

	</div>

  </div>

  <div class="section" title="2.4&nbsp;RestTemplate Constructors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-constructors"></a>2.4&nbsp;RestTemplate Constructors</h2></div></div></div>
	
	
	
	<p>The four <code class="classname">RestTemplate</code> constructors are listed below. The default constructor does not include any message body converters. You must add a message converter when using the default constructor. If you would like to include a default set of message converters with a new <code class="classname">RestTemplate</code> instance, then you can pass <code class="literal">true</code> for the <code class="literal">includeDefaultConverters</code> parameter. For a list of default converters, see the <a class="link" href="rest-template.html#rest-template-message-converters" title="2.6&nbsp;HTTP Message Conversion">HTTP Message Conversion</a> section. Additionally, if you would like to specify a different <code class="interfacename">ClientHttpRequestFactory</code> then you can do so by passing it in to the <code class="literal">requestFactory</code> parameter.
	
		</p><pre class="programlisting">
RestTemplate();

RestTemplate(<span class="hl-keyword">boolean</span> includeDefaultConverters);

RestTemplate(ClientHttpRequestFactory requestFactory);

RestTemplate(<span class="hl-keyword">boolean</span> includeDefaultConverters, ClientHttpRequestFactory requestFactory);
		</pre><p>
	
	</p>
	
  </div>

  <div class="section" title="2.5&nbsp;RestTemplate Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-methods"></a>2.5&nbsp;RestTemplate Methods</h2></div></div></div>
		
	
	
	<p><code class="classname">RestTemplate</code> provides higher level methods that correspond to each of the six main HTTP methods.  These methods make it easy to invoke many RESTful services and enforce REST best practices.</p>
	
	<p>The names of <code class="classname">RestTemplate</code> methods follow a naming convention, the first part indicates what HTTP method is being invoked and the second part indicates what is returned. For example, the method <code class="methodname">getForObject()</code> will perform a GET, convert the HTTP response into an object type of your choice and return that object. The method <code class="methodname">postForLocation()</code> will do a POST, converting the given object into a HTTP request and return the response HTTP Location header where the newly created object can be found. In case of an exception processing the HTTP request, an exception of the type <code class="classname">RestClientException</code> will be thrown.  This behavior can be changed by plugging in another <code class="interfacename">ResponseErrorHandler</code> implementation into the <code class="classname">RestTemplate.</code></p>
	
	<p>For more information on <code class="classname">RestTemplate</code> and it's associated methods, please refer to the <a class="ulink" href="http://static.springsource.org/spring-android/docs/1.0.x/api/org/springframework/web/client/RestTemplate.html" target="_top">API Javadoc</a></p>
	
	<div class="section" title="2.5.1&nbsp;HTTP DELETE"><div class="titlepage"><div><div><h3 class="title"><a name="d4e133"></a>2.5.1&nbsp;HTTP DELETE</h3></div></div></div>
		
		
		
		<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> delete(String url, Object... urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> delete(String url, Map&lt;String, ?&gt; urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> delete(URI url) <span class="hl-keyword">throws</span> RestClientException;
		</pre>

	</div>

	<div class="section" title="2.5.2&nbsp;HTTP GET"><div class="titlepage"><div><div><h3 class="title"><a name="d4e136"></a>2.5.2&nbsp;HTTP GET</h3></div></div></div>
		
		

		<pre class="programlisting">
<span class="hl-keyword">public</span> &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... urlVariables);

<span class="hl-keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables);

<span class="hl-keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) <span class="hl-keyword">throws</span> RestClientException;
		</pre>
		
	</div>

	<div class="section" title="2.5.3&nbsp;HTTP HEAD"><div class="titlepage"><div><div><h3 class="title"><a name="d4e139"></a>2.5.3&nbsp;HTTP HEAD</h3></div></div></div>

		

		<pre class="programlisting">
<span class="hl-keyword">public</span> HttpHeaders headForHeaders(String url, Object... urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> HttpHeaders headForHeaders(String url, Map&lt;String, ?&gt; urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> HttpHeaders headForHeaders(URI url) <span class="hl-keyword">throws</span> RestClientException;
		</pre>

	</div>
	
	<div class="section" title="2.5.4&nbsp;HTTP OPTIONS"><div class="titlepage"><div><div><h3 class="title"><a name="d4e142"></a>2.5.4&nbsp;HTTP OPTIONS</h3></div></div></div>

		

		<pre class="programlisting">
<span class="hl-keyword">public</span> Set&lt;HttpMethod&gt; optionsForAllow(String url, Object... urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> Set&lt;HttpMethod&gt; optionsForAllow(String url, Map&lt;String, ?&gt; urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> Set&lt;HttpMethod&gt; optionsForAllow(URI url) <span class="hl-keyword">throws</span> RestClientException;
		</pre>

	</div>
	
	<div class="section" title="2.5.5&nbsp;HTTP POST"><div class="titlepage"><div><div><h3 class="title"><a name="d4e145"></a>2.5.5&nbsp;HTTP POST</h3></div></div></div>

		

		<pre class="programlisting">
<span class="hl-keyword">public</span> URI postForLocation(String url, Object request, Object... urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> URI postForLocation(String url, Object request, Map&lt;String, ?&gt; urlVariables);

<span class="hl-keyword">public</span> URI postForLocation(URI url, Object request) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables);

<span class="hl-keyword">public</span> &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables);

<span class="hl-keyword">public</span> &lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables);

<span class="hl-keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) <span class="hl-keyword">throws</span> RestClientException;
		</pre>

	</div>
	
	<div class="section" title="2.5.6&nbsp;HTTP PUT"><div class="titlepage"><div><div><h3 class="title"><a name="d4e148"></a>2.5.6&nbsp;HTTP PUT</h3></div></div></div>

		

		<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> put(String url, Object request, Object... urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> put(String url, Object request, Map&lt;String, ?&gt; urlVariables) <span class="hl-keyword">throws</span> RestClientException;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> put(String url, Object request, Map&lt;String, ?&gt; urlVariables) <span class="hl-keyword">throws</span> RestClientException;
		</pre>

	</div>
	
  </div>


  <div class="section" title="2.6&nbsp;HTTP Message Conversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-message-converters"></a>2.6&nbsp;HTTP Message Conversion</h2></div></div></div>

	

	<p>Objects passed to and returned from the methods <code class="methodname">getForObject()</code>, <code class="methodname">getForEntity()</code>, <code class="methodname">postForLocation()</code>, <code class="methodname">postForObject()</code> and <code class="methodname">put()</code> are converted to HTTP requests and from HTTP responses by <code class="interfacename">HttpMessageConverter</code> instances. The <code class="interfacename">HttpMessageConverter</code> interface is shown below to give you a better feel for its functionality.</p>

	<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> HttpMessageConverter&lt;T&gt; {

    <span class="hl-comment">// Indicates whether the given class can be read by this converter.</span>
    <span class="hl-keyword">boolean</span> canRead(Class&lt;?&gt; clazz, MediaType mediaType);

    <span class="hl-comment">// Indicates whether the given class can be written by this converter.</span>
    <span class="hl-keyword">boolean</span> canWrite(Class&lt;?&gt; clazz, MediaType mediaType);

    <span class="hl-comment">// Return the list of {@link MediaType} objects supported by this converter.</span>
    List&lt;MediaType&gt; getSupportedMediaTypes();

    <span class="hl-comment">// Read an object of the given type form the given input message, and returns it.</span>
    T read(Class&lt;? <span class="hl-keyword">extends</span> T&gt; clazz, HttpInputMessage inputMessage)
            <span class="hl-keyword">throws</span> IOException, HttpMessageNotReadableException;

    <span class="hl-comment">// Write an given object to the given output message.</span>
    <span class="hl-keyword">void</span> write(T t, MediaType contentType, HttpOutputMessage outputMessage)
            <span class="hl-keyword">throws</span> IOException, HttpMessageNotWritableException;

}
	</pre>	

	<p>Concrete implementations for the main media (mime) types are provided in the framework.</p>
	
	<div class="section" title="2.6.1&nbsp;Default Message Converters"><div class="titlepage"><div><div><h3 class="title"><a name="d4e163"></a>2.6.1&nbsp;Default Message Converters</h3></div></div></div>
		
		
	
		<p>For performance reasons, the default <code class="classname">RestTemplate</code> constructor does not register any message converters. However, if you pass <code class="literal">true</code> to the alternate constructor, then converters for the main mime types are registered. You can also write your own converter and register it via the <code class="methodname">messageConverters</code> property.</p>
		
		<p>When using the alternate <code class="classname">RestTemplate</code> constructor, the default converter instances registered with the template are <code class="classname">ByteArrayHttpMessageConverter</code>, <code class="classname">StringHttpMessageConverter</code>, and <code class="classname">ResourceHttpMessageConverter</code>.  If your app is running on Android 2.2 or later, then <code class="classname">XmlAwareFormHttpMessageConverter</code> and <code class="classname">SourceHttpMessageConverter</code> are registered, as these two message converters require <code class="classname">javax.xml.transform.Source</code>. On Android 2.1, this falls back to the <code class="classname">FormHttpMessageConverter</code> which lacks some of the XML support in the other two. See the following table for more information.</p> 
	
		<table border="1" cellpadding="2" cellspacing="0" align="center" id="d4e178">
			<caption>Table&nbsp;2.1.&nbsp;Default Message Converters</caption>
			<thead>
				<tr><th>Message Body Converter</th><th>Inclusion Rule</th></tr>
			</thead>
			<tbody>
				<tr><td><a class="link" href="rest-template.html#ByteArrayHttpMessageConverter" title="ByteArrayHttpMessageConverter"><code class="classname">ByteArrayHttpMessageConverter</code></a></td><td rowspan="3" valign="top">Always included</td></tr>
				<tr><td><a class="link" href="rest-template.html#StringHttpMessageConverter" title="StringHttpMessageConverter"><code class="classname">StringHttpMessageConverter</code></a></td></tr>
				<tr><td><a class="link" href="rest-template.html#ResourceHttpMessageConverter" title="ResourceHttpMessageConverter"><code class="classname">ResourceHttpMessageConverter</code></a></td></tr>
				<tr><td><a class="link" href="rest-template.html#SourceHttpMessageConverter" title="SourceHttpMessageConverter"><code class="classname">SourceHttpMessageConverter</code></a></td><td rowspan="2" valign="top">Included on Android 2.2 (Froyo) or newer, where <code class="classname">javax.xml.transform.Source</code> is available.</td></tr>
				<tr><td><a class="link" href="rest-template.html#XmlAwareFormHttpMessageConverter" title="XmlAwareFormHttpMessageConverter"><code class="classname">XmlAwareFormHttpMessageConverter</code></a></td></tr>
				<tr><td><a class="link" href="rest-template.html#FormHttpMessageConverter" title="FormHttpMessageConverter"><code class="classname">FormHttpMessageConverter</code></a></td><td>Included on Android 2.1 (Eclair) and older.</td></tr>
				<tr><td><a class="link" href="rest-template.html#SimpleXmlHttpMessageConverter" title="SimpleXmlHttpMessageConverter"><code class="classname">SimpleXmlHttpMessageConverter</code></a></td><td>Included if the Simple XML serializer is present.</td></tr>
				<tr><td><a class="link" href="rest-template.html#MappingJacksonHttpMessageConverter" title="MappingJacksonHttpMessageConverter"><code class="classname">MappingJacksonHttpMessageConverter</code></a></td><td>Included if the Jackson JSON processor is present.</td></tr>
				<tr><td><a class="link" href="rest-template.html#SyndFeedHttpMessageConverter" title="SyndFeedHttpMessageConverter"><code class="classname">SyndFeedHttpMessageConverter</code></a></td><td>Included if the Android ROME Feed Reader is present.</td></tr>
			</tbody>
		</table>
	
	</div>

	<div class="section" title="2.6.2&nbsp;Available Message Converters"><div class="titlepage"><div><div><h3 class="title"><a name="d4e228"></a>2.6.2&nbsp;Available Message Converters</h3></div></div></div>
		
		
		
	<p>The following <code class="interfacename">HttpMessageConverter</code> implementations are available in Spring for Android. For all converters a default media type is used but can be overridden through the <code class="methodname">supportedMediaTypes</code> property.</p>

	<div class="section" title="ByteArrayHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="ByteArrayHttpMessageConverter"></a>ByteArrayHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write byte arrays from the HTTP request and response. By default, this converter supports all media types (<code class="literal">*/*</code>), and writes with a <code class="literal">Content-Type</code> of <code class="literal">application/octet-stream</code>. This can be overridden by setting the supportedMediaTypes property, and overriding <code class="methodname">getContentType(byte[])</code>.</p>

	</div>
	
	<div class="section" title="FormHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="FormHttpMessageConverter"></a>FormHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write form data from the HTTP request and response. By default, this converter reads and writes the media type <code class="literal">application/x-www-form-urlencoded</code>. Form data is read from and written into a <code class="literal">MultiValueMap&lt;String, String&gt;</code>.</p>

	</div>
	
	<div class="section" title="XmlAwareFormHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="XmlAwareFormHttpMessageConverter"></a>XmlAwareFormHttpMessageConverter</h4></div></div></div>

		

		<p>Extension of <code class="classname">FormHttpMessageConverter</code>, adding support for XML-based parts through a <code class="classname"> SourceHttpMessageConverter</code></p>

	</div>
	
	<div class="section" title="ResourceHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="ResourceHttpMessageConverter"></a>ResourceHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write <code class="interfacename">Resource</code> Resources. By default, this converter can read all media types. <code class="literal">application/octet-stream</code> is used to determine the <code class="classname">Content-Type</code> of written resources</p>

	</div>
	
	<div class="section" title="SourceHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="SourceHttpMessageConverter"></a>SourceHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write <code class="classname">javax.xml.transform.Source</code> from the HTTP request and response. Only <code class="classname">DOMSource</code>, <code class="classname">SAXSource</code>, and <code class="classname">StreamSource</code> are supported. By default, this converter supports <code class="literal">text/xml</code> and <code class="literal">application/xml</code>.</p>

	</div>

	<div class="section" title="StringHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="StringHttpMessageConverter"></a>StringHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write Strings from the HTTP request and response. By default, this converter supports all text media types (<code class="literal">text/*</code>), and writes with a <code class="literal">Content-Type</code> of <code class="literal">text/plain</code>.</p>

	</div>

	<div class="section" title="SimpleXmlHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="SimpleXmlHttpMessageConverter"></a>SimpleXmlHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write XML from the HTTP request and response using <a class="ulink" href="http://simple.sourceforge.net" target="_top">Simple Framework</a>'s <code class="interfacename">Serializer</code>. XML mapping can be customized as needed through the use of Simple's provided annotations. When additional control is needed, a custom <code class="interfacename">Serializer</code> can be injected through the <code class="interfacename">Serializer</code> property. By default, this converter reads and writes the media types <code class="literal">application/xml</code>, <code class="literal">text/xml</code>, and <code class="literal">application/*+xml</code>.</p>

		<p>It is important to note that this is not a Spring OXM compatible message converter. It is a standalone implementation that enables XML serialization through Spring for Android.</p>
		
		<p>Add the following dependency to your classpath to enable the <code class="classname">SimpleXmlHttpMessageConverter</code>.
		
			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.simpleframework<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>simple-xml<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${simple-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>
		
		</p>

	</div>

	<div class="section" title="MappingJacksonHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="MappingJacksonHttpMessageConverter"></a>MappingJacksonHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write JSON using <a class="ulink" href="http://jackson.codehaus.org" target="_top">Jackson JSON Processor</a>'s <code class="classname">ObjectMapper</code>. JSON mapping can be customized as needed through the use of Jackson's provided annotations. When further control is needed, a custom <code class="classname">ObjectMapper</code> can be injected through the <code class="classname">ObjectMapper</code> property for cases where custom JSON serializers/deserializers need to be provided for specific types. By default this converter supports <code class="literal">application/json</code>.</p>
		
		<p>Please note that this message converter and the <code class="classname">GsonHttpMessageConverter</code> both support <code class="literal">application/json</code> by default. Because of this, you should only add one JSON message converter to a <code class="classname">RestTemplate</code> instance. <code class="classname">RestTemplate</code> will use the first converter it finds that matches the specified mime type, so including both could produce unintended results.</p>
		
		<p>Include the following dependencies in your classpath to enable the <code class="classname">MappingJacksonHttpMessageConverter</code>. Please note that if you are manually copying the jars into your project, you will also need to include the <code class="literal">jackson-core-asl</code> jar.
		
			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.codehaus.jackson<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>jackson-mapper-asl<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${jackson-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>
		
		</p>

	</div>

	<div class="section" title="GsonHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="GsonHttpMessageConverter"></a>GsonHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write JSON using <a class="ulink" href="http://code.google.com/p/google-gson/" target="_top">Google Gson</a>'s <code class="classname">Gson</code> class. JSON mapping can be customized as needed through the use of Gson's provided annotations. When further control is needed, a custom <code class="classname">Gson</code> can be injected through the <code class="classname">Gson</code> property for cases where custom JSON serializers/deserializers need to be provided for specific types. By default this converter supports <code class="literal">application/json</code>.</p>

		<p>Please note that this message converter and the <code class="classname">MappingJacksonHttpMessageConverter</code> both support <code class="literal">application/json</code> by default. Because of this, you should only add one JSON message converter to a <code class="classname">RestTemplate</code> instance. <code class="classname">RestTemplate</code> will use the first converter it finds that matches the specified mime type, so including both could produce unintended results.</p>
		
		<p>Include the following dependency in your classpath to enable the <code class="classname">GsonHttpMessageConverter</code>.

			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>com.google.code.gson<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>gson<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${gson-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>
					
		</p>

	</div>
	
	<div class="section" title="SyndFeedHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="SyndFeedHttpMessageConverter"></a>SyndFeedHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write RSS and Atom feeds from the HTTP request and response using <a class="ulink" href="http://code.google.com/p/android-rome-feed-reader" target="_top">Android ROME Feed Reader</a>. The data is read from and written into a <code class="classname">com.google.code.rome.android.repackaged.com.sun.syndication.feed.synd.SyndFeed</code>. By default, this converter supports <code class="literal">application/rss+xml</code> and <code class="literal">application/atom+xml</code>.</p>
		
		<p>Add the following dependencies to your classpath to enable the <code class="classname">SyndFeedHttpMessageConverter</code>, <code class="classname">RssChannelHttpMessageConverter</code>, or <code class="classname">AtomFeedHttpMessageConverter</code>. This library depends on a forked version of JDOM to work on Android 2.1 and earlier. The JDOM library addresses a <a class="ulink" href="http://www.jdom.org/pipermail/jdom-interest/2009-July/016345.html" target="_top">bug</a> in the Android XML parser.
		
			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>com.google.code.android-rome-feed-reader<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>android-rome-feed-reader<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${android-rome-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>
		
			</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.jdom<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>jdom<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${jdom-fork-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
			</pre><p>
			
		</p>
		
		<p>The Android ROME Feed Reader is not available through Maven Central. When using Maven, you will need to include the following repository in your POM.
		
			</p><pre class="programlisting">
<span class="hl-comment">&lt;!-- For developing with Android ROME Feed Reader --&gt;</span>
<span class="hl-tag">&lt;repository&gt;</span>
    <span class="hl-tag">&lt;id&gt;</span>android-rome-feed-reader-repository<span class="hl-tag">&lt;/id&gt;</span>
    <span class="hl-tag">&lt;name&gt;</span>Android ROME Feed Reader Repository<span class="hl-tag">&lt;/name&gt;</span>
    <span class="hl-tag">&lt;url&gt;</span>https://android-rome-feed-reader.googlecode.com/svn/maven2/releases<span class="hl-tag">&lt;/url&gt;</span>
<span class="hl-tag">&lt;/repository&gt;</span>
			</pre><p>
		
		</p>

	</div>
	
	<div class="section" title="RssChannelHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="RssChannelHttpMessageConverter"></a>RssChannelHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write RSS feeds from the HTTP request and response using <a class="ulink" href="http://code.google.com/p/android-rome-feed-reader" target="_top">Android ROME Feed Reader</a>. The data is read from and written into a <code class="classname">com.google.code.rome.android.repackaged.com.sun.syndication.feed.rss.Channel</code>. By default, this converter supports <code class="literal">application/rss+xml</code>.</p>
		
		<p>The <code class="classname">SyndFeedHttpMessageConverter</code> provides a higher level of abstraction around RSS and Atom feeds, the <code class="classname">RssChannelHttpMessageConverter</code> is not included in the default set of message converters when you create a new <code class="classname">RestTemplate</code> instance. If you prefer to use this message converter then you have to manually add it to the <code class="classname">RestTemplate</code> instance.
		</p>
		
		<p>See the <a class="link" href="rest-template.html#SyndFeedHttpMessageConverter" title="SyndFeedHttpMessageConverter"><code class="classname">SyndFeedHttpMessageConverter</code></a> section for information about the required <a class="ulink" href="http://code.google.com/p/android-rome-feed-reader" target="_top">Android ROME Feed Reader</a> dependencies.</p>
		
	</div>
	
	<div class="section" title="AtomFeedHttpMessageConverter"><div class="titlepage"><div><div><h4 class="title"><a name="AtomFeedHttpMessageConverter"></a>AtomFeedHttpMessageConverter</h4></div></div></div>

		

		<p>An <code class="interfacename">HttpMessageConverter</code> implementation that can read and write Atom feeds from the HTTP request and response using <a class="ulink" href="http://code.google.com/p/android-rome-feed-reader" target="_top">Android ROME Feed Reader</a>. The data is read from and written into a <code class="classname">com.google.code.rome.android.repackaged.com.sun.syndication.feed.atom.Feed</code>. By default, this converter supports <code class="literal">application/atom+xml</code>.</p>
		
		<p>Because the <code class="classname">SyndFeedHttpMessageConverter</code> provides a higher level of abstraction around RSS and Atom feeds, the <code class="classname">AtomFeedHttpMessageConverter</code> is not included in the default set of message converters when you create a new <code class="classname">RestTemplate</code> instance. If you prefer to use this message converter then you have to manually add it to the <code class="classname">RestTemplate</code> instance.
		</p>
		
		<p>See the <a class="link" href="rest-template.html#SyndFeedHttpMessageConverter" title="SyndFeedHttpMessageConverter"><code class="classname">SyndFeedHttpMessageConverter</code></a> section for information about the required <a class="ulink" href="http://code.google.com/p/android-rome-feed-reader" target="_top">Android ROME Feed Reader</a> dependencies.</p>
		
	</div>
	
	</div>

  </div>

  <div class="section" title="2.7&nbsp;Usage Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-template-examples"></a>2.7&nbsp;Usage Examples</h2></div></div></div>
	
  	

  	<p>Using <code class="classname">RestTemplate</code>, it's easy to invoke RESTful APIs.  Below are several usage examples that illustrate the different methods for making RESTful requests.</p>
	
	<p>All of the following examples are based on a <a class="ulink" href="https://github.com/SpringSource/spring-android-samples" target="_top">sample Android application</a>. You can retrieve the source code for the sample app with the following command:</p>
	
	<pre class="programlisting">
$ git clone git://github.com/SpringSource/spring-android-samples.git
	</pre>	

  	<div class="section" title="2.7.1&nbsp;Basic Usage Example"><div class="titlepage"><div><div><h3 class="title"><a name="d4e382"></a>2.7.1&nbsp;Basic Usage Example</h3></div></div></div>
	
		
		
		<p>The following example shows a query to google for the search term "SpringSource".</p>
		
		<pre class="programlisting">
String url = <span class="hl-string">"https://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q={query}"</span>;
			
<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the String message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> StringHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response to a String</span>
String result = restTemplate.getForObject(url, String.<span class="hl-keyword">class</span>, <span class="hl-string">"SpringSource"</span>);
		</pre>
		
	</div>
	
  	<div class="section" title="2.7.2&nbsp;Using Gzip Compression"><div class="titlepage"><div><div><h3 class="title"><a name="d4e386"></a>2.7.2&nbsp;Using Gzip Compression</h3></div></div></div>

		

		<p>Gzip compression can significantly reduce the size of the response data being returned in a REST request. Gzip must be supported by the web server to which the request is being made. By setting the content coding type of the <code class="literal">Accept-Encoding</code> header to <code class="literal">gzip</code>, you are requesting that the server respond using gzip compression. If gzip is available, or enabled on the server, then it should return a compressed response. RestTemplate checks the <code class="literal">Content-Encoding</code> header in the response to determine if, in fact, the response is gzip compressed. At this time, RestTemplate only supports the gzip content coding type in the <code class="literal">Content-Encoding</code> header. If the response data is determined to be gzip compressed, then a <a class="ulink" href="http://developer.android.com/reference/java/util/zip/GZIPInputStream.html" target="_top"><code class="classname">GZIPInputStream</code></a> is used to decompress it.</p>
		
		<p>The following example shows how to request a gzip compressed response from the server.</p>

		<pre class="programlisting">
<span class="hl-comment">// Add the gzip Accept-Encoding header</span>
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setAcceptEncoding(ContentCodingType.GZIP);
HttpEntity&lt;?&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Object&gt;(requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the String message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> StringHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response to a String</span>
ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String.<span class="hl-keyword">class</span>);
		</pre>
		
		<p>One thing to note, is that when using the J2SE facilities with the <code class="classname">SimpleClientHttpRequestFactory</code>, Gingerbread and newer automatically set the Accept-Encoding header to request gzip responses. This is built in functionality of newer versions of Android. If you desire to disable gzip, then you must set the <code class="literal">identity</code> value in the header.</p>

		<pre class="programlisting">
<span class="hl-comment">// Add the identity Accept-Encoding header</span>
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setAcceptEncoding(ContentCodingType.IDENTITY);
HttpEntity&lt;?&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Object&gt;(requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the String message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> StringHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response to a String</span>
ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String.<span class="hl-keyword">class</span>);
		</pre>

	</div>
  
	<div class="section" title="2.7.3&nbsp;Retrieving JSON data via HTTP GET"><div class="titlepage"><div><div><h3 class="title"><a name="d4e401"></a>2.7.3&nbsp;Retrieving JSON data via HTTP GET</h3></div></div></div>
		
		
		
		<p>Suppose you have defined a Java object you wish to populate from a RESTful web request that returns JSON content.</p>
		
		<p>Define your object based on the JSON data being returned from the RESTful request:</p>
		
		<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Event {

    <span class="hl-keyword">private</span> Long id;

    <span class="hl-keyword">private</span> String title;
	
    <span class="hl-keyword">public</span> Long getId() {
        <span class="hl-keyword">return</span> id;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(Long id) {
        <span class="hl-keyword">this</span>.id = id;
    }

    <span class="hl-keyword">public</span> String getTitle() {
        <span class="hl-keyword">return</span> title;
    }
	
    <span class="hl-keyword">public</span> String setTitle(String title) {
        <span class="hl-keyword">this</span>.title = title;
    }
}
		</pre>
		
		<p>Make the REST request:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Jackson message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> MappingJacksonHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response from JSON to an array of Events</span>
Event[] events = restTemplate.getForObject(url, Event[].<span class="hl-keyword">class</span>);
		</pre>
		
		<p>You can also set the <code class="literal">Accept</code> header for the request:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Set the Accept header</span>
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setAccept(Collections.singletonList(<span class="hl-keyword">new</span> MediaType(<span class="hl-string">"application"</span>,<span class="hl-string">"json"</span>)));
HttpEntity&lt;?&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Object&gt;(requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Jackson message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> MappingJacksonHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response from JSON to an array of Events</span>
ResponseEntity&lt;Event[]&gt; responseEntity = restTemplate.exchange(url, HttpMethod.GET, requestEntity, Event[].<span class="hl-keyword">class</span>);
Event[] events = responseEntity.getBody();
		</pre>
		
		<p>Alternatively, you can use the <code class="classname">GsonHttpMessageConverter</code> for JSON marshaling. The following repeats the same request, utilizing Gson.</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Set the Accept header</span>
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setAccept(Collections.singletonList(<span class="hl-keyword">new</span> MediaType(<span class="hl-string">"application"</span>,<span class="hl-string">"json"</span>)));
HttpEntity&lt;?&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Object&gt;(requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Gson message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> GsonHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response from JSON to an array of Events</span>
ResponseEntity&lt;Event[]&gt; responseEntity = restTemplate.exchange(url, HttpMethod.GET, requestEntity, Event[].<span class="hl-keyword">class</span>);
Event[] events = responseEntity.getBody();
		</pre>
		
	</div>
	
	<div class="section" title="2.7.4&nbsp;Retrieving XML data via HTTP GET"><div class="titlepage"><div><div><h3 class="title"><a name="d4e414"></a>2.7.4&nbsp;Retrieving XML data via HTTP GET</h3></div></div></div>
		
		
		
		<p>Using the same Java object we defined earlier, we can modify the requests to retrieve XML.</p>
		
		<p>Define your object based on the XML data being returned from the RESTful request. Note the annotations used by Simple to marshal the object:</p>
		
		<pre class="programlisting">
<i><span class="hl-annotation" style="color: gray">@Root</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Event {

    <i><span class="hl-annotation" style="color: gray">@Element</span></i>
    <span class="hl-keyword">private</span> Long id;

    <i><span class="hl-annotation" style="color: gray">@Element</span></i>
    <span class="hl-keyword">private</span> String title;

    <span class="hl-keyword">public</span> Long getId() {
        <span class="hl-keyword">return</span> id;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(Long id) {
        <span class="hl-keyword">this</span>.id = id;
    }

    <span class="hl-keyword">public</span> String getTitle() {
        <span class="hl-keyword">return</span> title;
    }

    <span class="hl-keyword">public</span> String setTitle(String title) {
        <span class="hl-keyword">this</span>.title = title;
    }
}
		</pre>
		
		<p>To marshal an array of events from xml, we need to define a wrapper class for the list:</p>
		
		<pre class="programlisting">
<i><span class="hl-annotation" style="color: gray">@Root(name="events")</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> EventList {

   <i><span class="hl-annotation" style="color: gray">@ElementList(inline=true)</span></i>
   <span class="hl-keyword">private</span> List&lt;Event&gt; events;

   <span class="hl-keyword">public</span> List&lt;Event&gt; getEvents() {
      <span class="hl-keyword">return</span> events;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setEvents(List&lt;Event&gt; events) {
       <span class="hl-keyword">this</span>.events = events;
   }
}
		</pre>
		
		<p>Make the REST request:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Simple XML message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> SimpleXmlHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response from XML to an EventList object</span>
EventList eventList = restTemplate.getForObject(url, EventList.<span class="hl-keyword">class</span>);
		</pre>
		
		<p>You can also specify the <code class="literal">Accept</code> header for the request:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Set the Accept header</span>
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setAccept(Collections.singletonList(<span class="hl-keyword">new</span> MediaType(<span class="hl-string">"application"</span>,<span class="hl-string">"xml"</span>)));
HttpEntity&lt;?&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Object&gt;(requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Simple XML message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> SimpleXmlHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response from XML to an EventList</span>
ResponseEntity&lt;EventList&gt; responseEntity = restTemplate.exchange(url, HttpMethod.GET, requestEntity, EventList.<span class="hl-keyword">class</span>);
EventList eventList = responseEntity.getBody();
		</pre>
		
	</div>
	
	<div class="section" title="2.7.5&nbsp;Send JSON data via HTTP POST"><div class="titlepage"><div><div><h3 class="title"><a name="d4e426"></a>2.7.5&nbsp;Send JSON data via HTTP POST</h3></div></div></div>
		
		
		
		<p>POST a Java object you have defined to a RESTful service that accepts JSON data.</p>
		
		<p>Define your object based on the JSON data expected by the RESTful request:</p>
		
		<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Message 
{
    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;

    <span class="hl-keyword">private</span> String subject;

    <span class="hl-keyword">private</span> String text;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">long</span> id) {
        <span class="hl-keyword">this</span>.id = id;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {
        <span class="hl-keyword">return</span> id;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSubject(String subject) {
        <span class="hl-keyword">this</span>.subject = subject;
    }

    <span class="hl-keyword">public</span> String getSubject() {
        <span class="hl-keyword">return</span> subject;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setText(String text) {
        <span class="hl-keyword">this</span>.text = text;
    }

    <span class="hl-keyword">public</span> String getText() {
        <span class="hl-keyword">return</span> text;
    }
}
		</pre>
		
		<p>Make the REST request. In this example, the request responds with a string value:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Create and populate a simple object to be used in the request</span>
Message message = <span class="hl-keyword">new</span> Message();
message.setId(<span class="hl-number">555</span>);
message.setSubject(<span class="hl-string">"test subject"</span>);
message.setText(<span class="hl-string">"test text"</span>);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Jackson and String message converters</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> MappingJacksonHttpMessageConverter());
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> StringHttpMessageConverter());

<span class="hl-comment">// Make the HTTP POST request, marshaling the request to JSON, and the response to a String</span>
String response = restTemplate.postForObject(url, message, String.<span class="hl-keyword">class</span>);
		</pre>
		
		<p>You can also specify the <code class="literal">Content-Type</code> header in your request:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Create and populate a simple object to be used in the request</span>
Message message = <span class="hl-keyword">new</span> Message();
message.setId(<span class="hl-number">555</span>);
message.setSubject(<span class="hl-string">"test subject"</span>);
message.setText(<span class="hl-string">"test text"</span>);

<span class="hl-comment">// Set the Content-Type header</span>
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setContentType(<span class="hl-keyword">new</span> MediaType(<span class="hl-string">"application"</span>,<span class="hl-string">"json"</span>));
HttpEntity&lt;Message&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Message&gt;(message, requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the Jackson and String message converters</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> MappingJacksonHttpMessageConverter());
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> StringHttpMessageConverter());

<span class="hl-comment">// Make the HTTP POST request, marshaling the request to JSON, and the response to a String</span>
ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.<span class="hl-keyword">class</span>);
String result = responseEntity.getBody();
		</pre>
	</div>
	
	<div class="section" title="2.7.6&nbsp;Retrieve RSS or Atom feed"><div class="titlepage"><div><div><h3 class="title"><a name="d4e436"></a>2.7.6&nbsp;Retrieve RSS or Atom feed</h3></div></div></div>
		
		
		
		<p>The following is a basic example of loading an RSS feed:</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the ROME message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> SyndFeedHttpMessageConverter());

<span class="hl-comment">// Make the HTTP GET request, marshaling the response to a SyndFeed object</span>
SyndFeed = restTemplate.getForObject(url, SyndFeed.<span class="hl-keyword">class</span>);
		</pre>
		
		<p>It is possible that you need to adjust the Media Type associated with the <code class="classname">SyndFeedHttpMessageConverter</code>. By default, the converter is associated with <code class="literal">application/rss+xml</code> and <code class="literal">application/atom+xml</code>.  An RSS feed might instead have a media type of <code class="literal">text/xml</code>, for example. The following code illustrates how to set the media type.</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Set the alternate mime type for the message converter</span>
SyndFeedHttpMessageConverter syndFeedConverter = <span class="hl-keyword">new</span> SyndFeedHttpMessageConverter();
syndFeedConverter.setSupportedMediaTypes(Collections.singletonList(MediaType.TEXT_XML));

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the ROME message converter</span>
restTemplate.getMessageConverters().add(syndFeedConverter);

<span class="hl-comment">// Make the HTTP GET request, marshaling the response to a SyndFeed object</span>
SyndFeed feed = restTemplate.getForObject(url, SyndFeed.<span class="hl-keyword">class</span>);
		</pre>
		
	</div>
	
	<div class="section" title="2.7.7&nbsp;HTTP Basic Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="d4e446"></a>2.7.7&nbsp;HTTP Basic Authentication</h3></div></div></div>
		
		
		
		<p>This example illustrates how to populate the <a class="ulink" href="http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#BasicAA" target="_top">HTTP Basic Authentication</a> header with the username and password. If the username and password are accepted, then you will receive the response from the request. If they are not accepted, then the server is supposed to return an <a class="ulink" href="http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#Code401" target="_top">HTTP 401 Unauthorized</a> response. Internally, RestTemplate handles the response, then throws an <code class="classname">HttpClientErrorException</code>. By calling <code class="methodname">getStatusCode()</code> on this exception, you can determine the exact cause and handle it appropriately.</p>
		
		<pre class="programlisting">
<span class="hl-comment">// Set the username and password for creating a Basic Auth request</span>
HttpAuthentication authHeader = <span class="hl-keyword">new</span> HttpBasicAuthentication(username, password);
HttpHeaders requestHeaders = <span class="hl-keyword">new</span> HttpHeaders();
requestHeaders.setAuthorization(authHeader);
HttpEntity&lt;?&gt; requestEntity = <span class="hl-keyword">new</span> HttpEntity&lt;Object&gt;(requestHeaders);

<span class="hl-comment">// Create a new RestTemplate instance</span>
RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

<span class="hl-comment">// Add the String message converter</span>
restTemplate.getMessageConverters().add(<span class="hl-keyword">new</span> StringHttpMessageConverter());

<span class="hl-keyword">try</span> {
    <span class="hl-comment">// Make the HTTP GET request to the Basic Auth protected URL</span>
    ResponseEntity&lt;Message&gt; response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String.<span class="hl-keyword">class</span>);
    <span class="hl-keyword">return</span> response.getBody();
} <span class="hl-keyword">catch</span> (HttpClientErrorException e) {
    Log.e(TAG, e.getLocalizedMessage(), e);
    <span class="hl-comment">// Handle 401 Unauthorized response</span>
}
		</pre>
	
	</div>
	
  </div>

</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overview.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="auth.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;Spring for Android Overview&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;3.&nbsp;Auth Module</td></tr></table></div></body></html>